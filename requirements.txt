# --- STEP 1: Choose a base image ---
# Use an official Python runtime as a base image.
# We choose a slim version for smaller image size.
# 'python:3.9-slim-buster' is a good balance of size and compatibility.
# Adjust the Python version if needed (e.g., 3.10, 3.11).
FROM python:3.9-slim-buster

# --- STEP 2: Set environment variables (optional but good practice) ---
# Set environment variables specific to your application.
# For example, if you're using Flask, this tells it where your app is.
# ENV FLASK_APP=app.py # Uncomment if using Flask with 'flask run' in CMD
# ENV PYTHONUNBUFFERED=1 # Ensures Python output is not buffered, useful for logs

# --- STEP 3: Set the working directory ---
# Set the working directory inside the container.
# All subsequent commands will be executed relative to this directory.
WORKDIR /app

# --- STEP 4: Copy dependency files and install them ---
# Copy *only* the requirements.txt file first.
# This leverages Docker's build cache: if requirements.txt doesn't change,
# this layer (and subsequent ones) won't be rebuilt, speeding up builds.
COPY requirements.txt .

# Install Python dependencies.
# --no-cache-dir: Reduces image size by not storing build cache.
# -r: Install from requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# --- STEP 5: Copy the rest of your application code ---
# Copy all other application files from your local machine to the container's /app directory.
# This assumes your Dockerfile is in the root of your project.
COPY . .

# --- STEP 6: Expose the port your API listens on ---
# Inform Docker that the container will listen on this port at runtime.
# This doesn't actually publish the port; it's just documentation.
# For Flask/FastAPI: typically 5000 or 8000
# For Django: typically 8000
EXPOSE 8000 # <--- IMPORTANT: Change this to your API's actual port

# --- STEP 7: Define the command to run your application ---
# This is the command that will be executed when a container starts from this image.
# We use a production-ready WSGI server like Gunicorn.

# For Flask/FastAPI (assuming your app instance is named 'app' in 'main.py' or 'app.py'):
# If your app is in app.py and the Flask/FastAPI instance is 'app':
# CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8000", "app:app"] # Change 8000 if needed

# If your app is in main.py and the FastAPI instance is 'app':
# CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "-b", "0.0.0.0:8000", "main:app"] # For FastAPI

# For Django (assuming your project is named 'cookmyfood_project' and your wsgi.py is in 'cookmyfood_project/wsgi.py'):
# CMD ["gunicorn", "--bind", "0.0.0.0:8000", "cookmyfood_project.wsgi:application"]

# Choose ONE of the CMD lines below based on your framework and application entry:

# Example for a Flask app in app.py with instance named 'app'
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8000", "app:app"]

# Example for a FastAPI app in main.py with instance named 'app'
# CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "-b", "0.0.0.0:8000", "main:app"]

# Example for a Django app where 'myproject' is your Django project name
# CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]